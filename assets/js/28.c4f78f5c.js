(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{770:function(v,_,t){"use strict";t.r(_);var a=t(18),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"数据库设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库设计"}},[v._v("#")]),v._v(" 数据库设计")]),v._v(" "),t("h2",{attrs:{id:"数据库概念设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库概念设计"}},[v._v("#")]),v._v(" 数据库概念设计")]),v._v(" "),t("h3",{attrs:{id:"基础概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础概念"}},[v._v("#")]),v._v(" 基础概念")]),v._v(" "),t("p",[v._v("将需求分析转换为实体-联系模型。")]),v._v(" "),t("ul",[t("li",[v._v("实体: 一个对象，类似于面向对象中的对象")]),v._v(" "),t("li",[v._v("实体集: 由多个实体组成的集合")]),v._v(" "),t("li",[v._v("属性: 实体的特征、性质")]),v._v(" "),t("li",[v._v("联系: 表示实体之间的关系，多个实体之间的联系")]),v._v(" "),t("li",[v._v("二元联系: 表示两个实体之间的联系，有如下三种关系\n"),t("ol",[t("li",[v._v("一对一")]),v._v(" "),t("li",[v._v("一对多")]),v._v(" "),t("li",[v._v("多对多")])])]),v._v(" "),t("li",[v._v("弱实体: 某个实体集的所有属性都不足以构成自身的键值，需要连接其他实体的某些属性来构成")])]),v._v(" "),t("h3",{attrs:{id:"设计准则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计准则"}},[v._v("#")]),v._v(" 设计准则")]),v._v(" "),t("ul",[t("li",[v._v("尽可能反映现实情况")]),v._v(" "),t("li",[v._v("避免重复")]),v._v(" "),t("li",[v._v("设计得尽可能简单，去除掉多余的元素")]),v._v(" "),t("li",[v._v("数据库应该选择合理的关系(如果一个关系可以被其他关系推出，那么这个关系就是不必要的)")]),v._v(" "),t("li",[v._v("正确选择所用的信息:\n"),t("ul",[t("li",[v._v("一个东西要成为实体，应该要有很多信息来描述，否则应该要当成属性")]),v._v(" "),t("li",[v._v("多元关系和多个二元关系的选择——看实际情况，符合现实即可")])])]),v._v(" "),t("li",[v._v("不应该过度使用弱实体集")])]),v._v(" "),t("h3",{attrs:{id:"e-r模型转化为关系模型的一般规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#e-r模型转化为关系模型的一般规则"}},[v._v("#")]),v._v(" E-R模型转化为关系模型的一般规则")]),v._v(" "),t("h4",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),t("ul",[t("li",[v._v("一对一关系")])]),v._v(" "),t("p",[v._v("对于实体集A的实体，在实体集B中至多有1个实体与实体集A联系，A和B具有1:1的联系")]),v._v(" "),t("ul",[t("li",[v._v("一对多关系")])]),v._v(" "),t("p",[v._v("对于实体集A的实体，在实体集B中至多能找到n个与之联系；反过来说，实体集B中的每个实体，都跟实体集A中其中一个实体联系。实体集A和实体集B具有1:n的联系")]),v._v(" "),t("ul",[t("li",[v._v("多对多关系")])]),v._v(" "),t("p",[v._v("实体集A中的每个实体与实体集B中的每个实体都有联系。")]),v._v(" "),t("h4",{attrs:{id:"转换规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转换规则"}},[v._v("#")]),v._v(" 转换规则")]),v._v(" "),t("h5",{attrs:{id:"二元关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二元关系"}},[v._v("#")]),v._v(" 二元关系")]),v._v(" "),t("ul",[t("li",[v._v("1:1联系(S,T)")])]),v._v(" "),t("p",[v._v("选中一个关系模式，假设为S,将T的主码作为S的外码加入，将联系的单值属性加入到S中")]),v._v(" "),t("ul",[t("li",[v._v("1:N联系(S,T)")])]),v._v(" "),t("p",[v._v("将1端的主码作为N的外码加入到N端。将联系的所有单值属性加入到N端")]),v._v(" "),t("ul",[t("li",[v._v("N:M(S,T)")])]),v._v(" "),t("p",[v._v("将联系转换为一个单独的关系模式，该关系模式的属性包括两端实体的码和联系本身的属性。")]),v._v(" "),t("h5",{attrs:{id:"多元关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多元关系"}},[v._v("#")]),v._v(" 多元关系")]),v._v(" "),t("ul",[t("li",[v._v("1:1:1(M,N,K)")])]),v._v(" "),t("p",[v._v("选定一个关系模式(K)，将另外两个关系模式(M,N)的码加入到K中作为外键。")]),v._v(" "),t("ul",[t("li",[v._v("1:1:N(M,N,K)")])]),v._v(" "),t("p",[v._v("将两个1端的关系模式(M,N)中的码，加入到K端的关系模式作为外键。")]),v._v(" "),t("ul",[t("li",[v._v("M:N:K(M,N,K)")])]),v._v(" "),t("p",[v._v("将该联系转化为关系模式，将三段的码加入到该关系模式当中。")])])}),[],!1,null,null,null);_.default=l.exports}}]);