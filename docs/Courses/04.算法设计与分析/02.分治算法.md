---
title: 分治算法
date: 2021-06-01 14:33:02
permalink: /courses/algorithm/divide-and-conquer
categories:
  - 课程学习
  - 算法设计与分析
tags: 
  - Algorithm
---

# 分治算法

::: tip
分治算法本质上也是递归，只不过是表现得比较抽象。

1. 划分子问题的过程就是在函数里面写递归的函数(自己调用自己)。
2. 求解就是在满足if的条件准备开始return的时候进行。
3. 最后合并的时候递归函数对应的那个系统栈出栈返回结果的过程。
:::

## 基本概念

分治算法的主要思想是划分子问题、求解子问题、合并所有解。用伪代码进行描述如下:
```
Divide-and-Conquer(P)   
1.  if  |P| <= c  then  S(P).
2.  divide P into P1, P2, …, Pk. //划分子问题
3.  for i = 1 to k 
4.    yi = Divide-and-Conquer(Pi)  //求解子问题
5．Return Merge(y1, y2, …, yk)  //结果合并
```

- 一般来说，最常用到的分析方式是递推方程。
- 求解方法主要有迭代法、递归树、主定理

## 实际例子应用


### 例:求一个数的幂

> 问题: 计算$a^n$, $n$为自然数

::: note 分析
算法核心: 将问题划分成多个子问题，这里是将求解幂这个问题进行拆分(一般都是**一分为二**)。因为求一个数的幂之后的结果，就是$n$个数$a$进行相乘。那么我们这样思考:$a^n$是由两个数相乘得到的，也就是$a^n=a^{\frac{n}{2}}\times a^{\frac{n}{2}}$，所以就可以多次递归求解。把求解$a^n$的问题拆分成求$a^{\frac{n}{2}}\times a^{\frac{n}{2}}$，这个步骤需要求解$a^{\frac{n}{2}}$，求解$a^{\frac{n}{2}}$又需要继续往下进行递归，最终递归完之后将所有结果进行合并，就得到了原问题的解。

两两相乘会出现两种情况:
1. $n$是奇数，此时因为是两两之间相乘，奇数必然会多出一个数没乘，所以就变成表达式为$a^n=a^{\frac{n-1}{2}}\times a^{\frac{n-1}{2}}\times a$(先减1变成偶数再乘多一个$a$)
2. $n$是偶数，此时因为是两两之间相乘，正好能够得到结果。所以表达式为$a^n=a^{\frac{n}{2}}\times a^{\frac{n}{2}}$(直接拆乘两个数相乘)
:::

- 传统做法:

> 根据定义做

```cpp
int main() {
    
    int a, n, sum = 1;
    cin >> a >> n;
    for (int i = 1 ; i <= n ; ++i) {
        sum *= a;
    } 
    cout << sum << endl;
    
    return 0;
}
```

- 分治做法:

```cpp
  int a, n, sum;
  int calc(int a, int n) {
      
      if (n == 1) {
          return pow(a, n) * pow(a, n);
      } else {
          if (n % 2 == 0) {
              sum = calc(a, n/ 2);
          } else {
              sum = calc(a, (n - 1) / 2) * a;
          }
      }
      return sum;
  }
  int main() {
      
      cin >> a >> n;
      sum = calc(a, n);
      cout << sum << endl;
      return 0;
  }
```

### 例:计算Fibonacci数

- 传统做法:

> 根据定义做

```cpp
#include <iostream>
using namespace std;
int main() {
  int a = 0, b = 1, res, n;
  cin >> n;
  if (n == 0) cout << a << endl;
  else if (n == 1) cout << b << endl;
  else {
    for (int i = 1; i <= n ;i ++) {
        res = a + b;
        b = a;
        a = res;
    }
    cout << res << endl;
  }
  return 0;
}
```

- 分治做法:

```cpp


```