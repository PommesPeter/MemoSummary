---
title: 算法基本概念
date: 2021-05-31 14:33:02
permalink: /courses/algorithm/concept
categories:
  - 课程学习
  - 算法设计与分析
tags: 
  - Algorithm
---

# 算法基础

著名的图灵奖获得者Donald E. Knuth曾经说:"Computer science is the study of algorithm"，也就是计算科学就是研究算法的科学。这门学科主要的学习方法是**通过经典算法的学习，积累经验，触类旁通，举一反三。**

::: note
算法设计这门课学的是发现解决问题的算法，同时证明算法是正确、有效和能被接受的。不仅仅是找到答案，更要证明答案。
:::

## 什么是算法？(基本概念)

算法是解决某个问题的一系列运算或操作。编译器和操作系统就是典型的例子。算法问题主要包括输入和输出

- 输入:明确了算法能够接受的合法输入
- 输出:明确对于一组合法的输入，相应所得到的结果是什么

数学公式:$output = f(input)$，其中$f(\cdot)$就表示算法。

## 伪代码

伪代码是一种能够将标准运行的程序通过简介明了的语言进行描述，其特点是保持了程序原本主要的结构，类似C语言等。语法规则如下:

- 赋值:$\larr$
- 分支:if...then...else
- 循环:while,for,repeat...until
- 输出:return
- 调用:写函数名
- 注释: //...

::: tip 特别注意！
需要特别注意的是，伪代码不能照搬原代码，需要进行部分精简，不需要具体的实现流程，只需要写出算法思路流程，**分为哪几步，不用详细写这几步的实现过程，只需要使用自然语言或者相应的函数替代**就行。忽略数据结构、模块、异常处理等。忽略变量的说明。
:::

### 例子

Insert_Sort:
输入: $n$个元素的数组$A$;
输出: 按非降序排列的数组$A$;

```none
for i <- 2 to n
  x <- A[i]
  j <- i - 1
  while (j > 0) and (x < A[j])
    A[j +  1] <- A[j]
    j <- j - 1
  A[j + 1] <- x
return A
```

## 算法复杂度

### 复杂度定义

算法的复杂度实际上是对算法执行次数的范围做一个估计。描述了一个算法执行次数至多和至少有多少，衡量一个算法的效率。描述的时候用到了高等数学中界的概念，一般有两种描述方式:

先设有任意正数$K_1$，使得有$f(n)\le K_1$，则称为$f(n)$的上界，记作$f(n)=O(K_1)$，其中$K_1=cg(n)$且存在正数$c$和$n_0$，对一切的$n\ge n_0$都成立。

同理，若任意正数$K_2$，使得有$f(n)\ge K_2$，则称为$f(n)$的下界，记作$f(n)=\Omega(K_2)$，其中$K_2=cg(n)$且存在正数$c$和$n_0$，对一切的$n\ge n_0$都成立。

如果，$f(n)=O(g(n))$且$f(n)=\Omega(g(n))$，则记作$f(n)=\Theta(g(n))$.

::: note $O(g(n))$与$\Omega(g(n))$的含义

- $O(g(n))$表示该算法至多执行$g(n)$次（最多）
- $\Omega(g(n))$表示该算法至少执行$g(n)$次（最少）

本质上算法复杂度会这样表示是因为简化表示，比如现在有一个程序的复杂度为$n\log n + n - 2$，如果直接表示的话就是$f(n)=n\log n+n-2$，但这样表示不够方便，而且有很多不必要的元素，因为算法复杂度其实不需要一个很精确的表示，因为就算你表示得很精确又不能说明什么，何必多此一举；而且在某个区间上来说，$n\log n \ge n$那我既然都不用表示那么完整了，何必又要再写$n$和$2$？直接用最大的那个表示出来就可以了。所以就可以写成$O(n\log n)$.

1. 不需要精确表示
2. 不需要精确表示就可以对式子进行化简，留下最大那个
3. 为什么留下最大那个，因为他起主导作用

:::

### 复杂度计算

